import os
from optparse import OptionParser



parser = OptionParser();
parser.add_option("-m", "--mesh", dest="mesh",
                  help="The name of the desired mesh file");
parser.add_option("-o", "--output", dest="output",
                  help="The name of the header file being generated")

(options, args) = parser.parse_args();
mesh = options.mesh;
output = options.output;
                  

f = open(output, "w+", newline = "\n");




f.write('//Cheese Pull -- peeling apart a cheese stick with a sphere boundary\n')
f.write('// ./anisofracture -test 9 [OPTIONS]\n')
f.write('\n')
f.write('//THESE PARAMETERS ARE FINAL, DO NOT CHANGE!!\n')
f.write('//Python params\n')
f.write('//residual = 0.01\n')
f.write('//percent = 0.19\n')
f.write('//eta = 0.1\n')
f.write('//fiberScale = 10\n')
f.write('\n')
f.write('sim.end_frame = 160;\n')
f.write('T frameRate = 24;\n')
f.write('sim.step.frame_dt = (T)1 / frameRate;\n')
f.write('sim.gravity = -3 * TV::Unit(1);\n')
f.write('sim.step.max_dt = 2e-4; //1.5 for fanfu\n')
f.write('sim.symplectic = true;\n')
f.write('sim.verbose = false;\n')
f.write('sim.cfl = 0.4;\n')
f.write('//sim.transfer_scheme = MpmSimulationBase<T, dim>::APIC_blend_RPIC;\n')
f.write('//sim.apic_rpic_ratio = 0.01;\n')
f.write('sim.transfer_scheme = MpmSimulationBase<T, dim>::FLIP_blend_PIC;\n')
f.write('sim.flip_pic_ratio = 0.0; //0 is full PIC\n')
f.write('//sim.rpic_damping_iteration = 5; //THis looks better without damping!\n')
f.write('sim.dump_F_for_meshing = true;\n')
f.write('T particle_per_cell = 7; //was 7 before\n')
f.write('\n')
f.write('T Youngs = 5000;\n')
f.write('T nu = 0.45;\n')
f.write('T rho = 500;\n')
f.write('\n')
f.write('// sample particles from a .mesh file\n')
f.write('std::string filename = "TetMesh/cheeseStick500k.mesh"; //50k is plenty for nice dynamics and no debris\n')
f.write('MpmParticleHandleBase<T, dim> particles_handle = init_helper.sampleFromTetWildFile(filename, rho);\n')
f.write('T total_volume = particles_handle.total_volume;\n')
f.write('T particle_count = particles_handle.particle_range.length();\n')
f.write('T per_particle_volume = total_volume / particle_count;\n')
f.write('\n')
f.write('// set dx\n')
f.write('sim.dx = std::pow(particle_per_cell * per_particle_volume, (T)1 / (T)3);\n')
f.write('\n')
f.write('//T suggested_dt = evaluateTimestepLinearElasticityAnalysis(Youngs, nu, rho, sim.dx, sim.cfl);\n')
f.write('//if (sim.symplectic) { ZIRAN_ASSERT(sim.step.max_dt <= suggested_dt, suggested_dt); }\n')
f.write('\n')
f.write('//Anisotropic fracture params, grab these from the flags\n')
f.write('StdVector<TV> a_0;\n')
f.write('StdVector<T> alphas;\n')
f.write('TV a_1, a_2;\n')
f.write('a_1[0] = 0;\n')
f.write('a_1[1] = 1; //fiber direction should always just be straight up\n')
f.write('a_1[2] = 0;\n')
f.write('a_1.normalize();\n')
f.write('a_0.push_back(a_1);\n')
f.write('if (Python::isotropic) {\n')
f.write('    alphas.push_back(0); //for isotropic set alpha 0\n')
f.write('}\n')
f.write('else {\n')
f.write('    alphas.push_back(-1); //for aniso set alpha -1\n')
f.write('}\n')
f.write('\n')
f.write('T percentage = Python::percent; //0.07 is good\n')
f.write('T l0 = 0.5 * sim.dx;\n')
f.write('T eta = Python::eta; //0.08 is good\n')
f.write('T zeta = 1;\n')
f.write('bool allow_damage = true;\n')
f.write('\n')
f.write('//Construct the file path\n')
f.write('\n')
f.write('std::string E_str = std::to_string(Youngs);\n')
f.write('E_str.erase(E_str.find_last_not_of(\'0\') + 1, std::string::npos);\n')
f.write('std::cout << "Youngs = " << Youngs << std::endl;\n')
f.write('\n')
f.write('std::string percent_str = std::to_string(percentage);\n')
f.write('percent_str.erase(percent_str.find_last_not_of(\'0\') + 1, std::string::npos);\n')
f.write('std::cout << "Percentage = " << percentage << std::endl;\n')
f.write('\n')
f.write('std::string eta_str = std::to_string(eta);\n')
f.write('eta_str.erase(eta_str.find_last_not_of(\'0\') + 1, std::string::npos);\n')
f.write('std::cout << "Eta = " << eta << std::endl;\n')
f.write('\n')
f.write('std::string scale_str = std::to_string(Python::fiberScale);\n')
f.write('scale_str.erase(scale_str.find_last_not_of(\'0\') + 1, std::string::npos);\n')
f.write('std::cout << "FiberScale = " << Python::fiberScale << std::endl;\n')
f.write('\n')
f.write('std::string res_str = std::to_string(Python::residual);\n')
f.write('res_str.erase(res_str.find_last_not_of(\'0\') + 1, std::string::npos);\n')
f.write('std::cout << "Residual = " << Python::residual << std::endl;\n')
f.write('\n')
f.write('std::string dx_str = std::to_string(sim.dx);\n')
f.write('dx_str.erase(dx_str.find_last_not_of(\'0\') + 1, std::string::npos);\n')
f.write('std::cout << "SimDx = " << sim.dx << std::endl;\n')
f.write('\n')
f.write('if (Python::isotropic) {\n')
f.write('    std::string path("output/3D_CheesePull/3D_CheesePull_Isotropic_Youngs" + E_str + "_percent" + percent_str + "_eta" + eta_str + "_dx" + dx_str + "_fiberScale" + scale_str + "_residual" + res_str);\n')
f.write('    sim.output_dir.path = path;\n')
f.write('}\n')
f.write('else {\n')
f.write('    std::string path("output/3D_CheesePull/3D_CheesePull_Youngs" + E_str + "_percent" + percent_str + "_eta" + eta_str + "_dx" + dx_str + "_fiberScale" + scale_str + "_residual" + res_str + "_slackANDholdAndRelease_andBetterSpacedCuts");\n')
f.write('    sim.output_dir.path = path;\n')
f.write('}\n')
f.write('\n')
f.write('// dump a vtk file in the output folder for mpmmeshing\n')
f.write('if (1) {\n')
f.write('    StdVector<TV> samples;\n')
f.write('    StdVector<Vector<int, 4>> indices;\n')
f.write('    std::string absolute_path = DataDir().absolutePath(filename);\n')
f.write('    readTetMeshTetWild(absolute_path, samples, indices);\n')
f.write('    sim.output_dir.createPath();\n')
f.write('    std::string vtk_path = DataDir().path + "/../Projects/anisofracture/" + sim.output_dir.path + "/tet.vtk";\n')
f.write('    writeTetmeshVtk(vtk_path, samples, indices);\n')
f.write('}\n')
f.write('\n')
f.write('init_helper.addAllWallsInDomain(4096 * sim.dx, 5 * sim.dx, AnalyticCollisionObject<T, dim>::STICKY); // add safety domain walls for SPGrid.\n')
f.write('\n')
f.write('//Add constitutive model, scale elasticity if needed, and add mpm force\n')
f.write('QRStableNeoHookean<T, dim> model(Youngs, nu);\n')
f.write('if (!Python::isotropic) {\n')
f.write('    model.setExtraFiberStiffness(0, Python::fiberScale); //only scale elasticity if anisotropic!\n')
f.write('}\n')
f.write('particles_handle.addFBasedMpmForceWithAnisotropicPhaseField(a_0, alphas, percentage, l0, model, eta, zeta, allow_damage, Python::residual);\n')
f.write('\n')
f.write('//Set up a ground plane\n')
f.write('TV ground_origin = TV(2, 1.75, 2);\n')
f.write('TV ground_normal(0, 1, 0);\n')
f.write('HalfSpace<T, dim> ground_ls(ground_origin, ground_normal);\n')
f.write('AnalyticCollisionObject<T, dim> ground_object(ground_ls, AnalyticCollisionObject<T, dim>::SEPARATE);\n')
f.write('ground_object.setFriction(0.5);\n')
f.write('init_helper.addAnalyticCollisionObject(ground_object);\n')
f.write('\n')
f.write('// Cheese Spine\n')
f.write('T spineRadius = sim.dx * 1.01; //make sure the spine is at least 2*dx wide!\n')
f.write('TV spineCenter(2, 2, 2);\n')
f.write('T spineHeight = 0.6;\n')
f.write('Vector<T, 4> q(1, 0, 0, 0);\n')
f.write('CappedCylinder<T, dim> spineLS(spineRadius, spineHeight, q, spineCenter);\n')
f.write('\n')
f.write('AnalyticCollisionObject<T, dim> spine_object(spineLS, AnalyticCollisionObject<T, dim>::STICKY);\n')
f.write('init_helper.addAnalyticCollisionObject(spine_object);\n')
f.write('\n')
f.write('T cutTheta = 26.57; //26.57 is BEST!! -- degrees down from x-axis that we will pull the cheese\n')
f.write('TV cutDir1(1.0, std::tan(cutTheta*(M_PI / 180.0)), 0); //this gives a sense of how much down and outward each cut should move based on theta\n')
f.write('cutDir1.normalize();\n')
f.write('TV cheeseCenter(2, 2, 2);\n')
f.write('\n')
f.write('TV base(2, 2.25, 2);\n')
f.write('TV startCenter(2, 2.255, 2.031); //2.031 is BEST!!!\n')
f.write('T sphereRadius = 0.015;\n')
f.write('TV baseCenter = startCenter - base;\n')
f.write('\n')
f.write('//define 12 cutters, three rounds of four cuts!\n')
f.write('//StdVector<T> cutList = { 0, 90, 180, 270, 30, 120, 210, 300 }; // 60, 150, 240, 330 }; //IN DEGREES!!!! this list determines the rotation of the cutter around the cheese, startCenter is considered theta = 0\n')
f.write('StdVector<T> cutList = { 0, 90, 180, 270, 45, 135, 225, 315 };\n')
f.write('\n')
f.write('//Define cutter behavior\n')
f.write('T cutTime = 1.25; //1.5, how long should cutter pull for?\n')
f.write('T cutDelay = 1; //1, how long should next cutter wait to start cutting?\n')
f.write('T slackDuration = 0.5; //0.5, how long to give the strand slack before releasing it\n')
f.write('T holdDuration = 0.5; //0.25 hold\n')
f.write('StdVector<T> startTimes = { 0, 0, 0, 0, cutDelay, cutDelay, cutDelay, cutDelay }; // cutDelay * 2, cutDelay * 2, cutDelay * 2, cutDelay * 2 };\n')
f.write('\n')
f.write('for (unsigned int i = 0; i < cutList.size(); i++) {\n')
f.write('\n')
f.write('    //Define next sphere center to cut with\n')
f.write('    T rotateTheta = cutList[i] * (M_PI / 180.0); //now we specifically define each cut!\n')
f.write('    TM rotateAroundYAxis;\n')
f.write('    rotateAroundYAxis << std::cos(rotateTheta), 0, -1 * std::sin(rotateTheta), 0, 1, 0, std::sin(rotateTheta), 0, std::cos(rotateTheta);\n')
f.write('    TV sphereCenter = (rotateAroundYAxis * baseCenter) + base;\n')
f.write('\n')
f.write('    TV cutDir2 = sphereCenter - cheeseCenter;\n')
f.write('    cutDir2[1] = 0; //zero out yDim\n')
f.write('    cutDir2.normalize(); //normalize after zeroing y\n')
f.write('\n')
f.write('    auto sphereTransform = [=](T time, AnalyticCollisionObject<T, dim>& object) {\n')
f.write('        //These parameters control the speed and scheduling of the cutters\n')
f.write('        T speed = 0.1; //how fast should cutter move?\n')
f.write('\n')
f.write('        T startTime = startTimes[i];\n')
f.write('        T endTime = startTime + cutTime;\n')
f.write('        T slackTime = endTime + slackDuration;\n')
f.write('        T holdTime = slackTime + holdDuration;\n')
f.write('\n')
f.write('        T xVel = speed * cutDir1[0] * cutDir2[0];\n')
f.write('        T yVel = -speed * cutDir1[1];\n')
f.write('        T zVel = speed * cutDir1[0] * cutDir2[2];\n')
f.write('        //        T x0 = sphereCenter[0];\n')
f.write('        //        T y0 = sphereCenter[1];\n')
f.write('        //        T z0 = sphereCenter[2];\n')
f.write('        T x0 = 0;\n')
f.write('        T y0 = 0;\n')
f.write('        T z0 = 0;\n')
f.write('\n')
f.write('        if (time < startTime) { //don\'t move yet\n')
f.write('            TV translation = TV(10, 10, 10);\n')
f.write('            TV translation_velocity(0, 0, 0);\n')
f.write('            object.setTranslation(translation, translation_velocity);\n')
f.write('        }\n')
f.write('        else if (time < endTime) { //normal translation\n')
f.write('            TV translation = TV(x0 + (xVel * (time - startTime)), y0 + (yVel * (time - startTime)), z0 + (zVel * (time - startTime)));\n')
f.write('            TV translation_velocity(xVel, yVel, zVel);\n')
f.write('            object.setTranslation(translation, translation_velocity);\n')
f.write('        }\n')
f.write('        else if (time < slackTime) { //slacken the strands before releasing\n')
f.write('            TV translation = TV(x0 + (xVel * (endTime - startTime)) - ((time - endTime) * (xVel * 0.5)), y0 + (yVel * (endTime - startTime)) - ((time - endTime) * (yVel * 0.5)), z0 + (zVel * (endTime - startTime)) - ((time - endTime) * (zVel * 0.5))); //move slightly in towards cheese\n')
f.write('            TV translation_velocity(-1 * xVel * 0.5, -1 * yVel * 0.5, -1 * zVel * 0.5);\n')
f.write('            object.setTranslation(translation, translation_velocity);\n')
f.write('        }\n')
f.write('        else if (time < holdTime) {\n')
f.write('            TV translation = TV(x0 + (xVel * (endTime - startTime)) - ((slackTime - endTime) * (xVel * 0.5)), y0 + (yVel * (endTime - startTime)) - ((slackTime - endTime) * (yVel * 0.5)), z0 + (zVel * (endTime - startTime)) - ((slackTime - endTime) * (zVel * 0.5))); //move slightly in towards cheese\n')
f.write('            TV translation_velocity(0, 0, 0); //trying slack time = hold still\n')
f.write('            object.setTranslation(translation, translation_velocity);\n')
f.write('        }\n')
f.write('        else { //teleport far away\n')
f.write('            TV translation = TV(99999, 99999, 99999);\n')
f.write('            TV translation_velocity(0, 0, 0);\n')
f.write('            object.setTranslation(translation, translation_velocity);\n')
f.write('        }\n')
f.write('        /*\n')
f.write('             *\n')
f.write('             *  if(time < 0.5) {\n')
f.write('             *      tranlsation = TV(time * vx, time * vy, time* vz)\n')
f.write('         *      }\n')
f.write('             *  else if (time < 0.8) {\n')
f.write('             *      translation  =TV(0.5 * vx - (t-0.5)* vx/3, 0.5 * vy, 0.5 *vz - (t-0.5)*vz/3)\n')
f.write('             *  }\n')
f.write('             *  else {\n')
f.write('             *      translation = TV(9,99,99)\n')
f.write('             *\n')
f.write('             *  }\n')
f.write('             *\n')
f.write('             *  }\n')
f.write('             *\n')
f.write('             *\n')
f.write('             */\n')
f.write('    };\n')
f.write('\n')
f.write('    Sphere<T, dim> sphere(sphereCenter, sphereRadius);\n')
f.write('    //Sphere<T, dim> sphere(TV(10,10,10), sphereRadius); //start all cutters far from cheese\n')
f.write('    AnalyticCollisionObject<T, dim> sphereObject(sphereTransform, sphere, AnalyticCollisionObject<T, dim>::STICKY);\n')
f.write('    init_helper.addAnalyticCollisionObject(sphereObject);\n')
f.write('}\n')


f.close();